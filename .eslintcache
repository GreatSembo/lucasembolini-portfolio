[{"C:\\Users\\lucas\\OneDrive\\Desktop\\GitHubProject\\typescript-porfolio-SP\\my-app\\src\\App.tsx":"1","C:\\Users\\lucas\\OneDrive\\Desktop\\GitHubProject\\typescript-porfolio-SP\\my-app\\src\\utils\\SVGLoader.js":"2","C:\\Users\\lucas\\OneDrive\\Desktop\\GitHubProject\\typescript-porfolio-SP\\my-app\\src\\utils\\OrbitControls.js":"3","C:\\Users\\lucas\\OneDrive\\Desktop\\GitHubProject\\typescript-porfolio-SP\\my-app\\src\\index.tsx":"4","C:\\Users\\lucas\\OneDrive\\Desktop\\GitHubProject\\typescript-porfolio-SP\\my-app\\src\\theme.js":"5","C:\\Users\\lucas\\OneDrive\\Desktop\\GitHubProject\\typescript-porfolio-SP\\my-app\\src\\assets\\logo.jsx":"6","C:\\Users\\lucas\\OneDrive\\Desktop\\GitHubProject\\typescript-porfolio-SP\\my-app\\src\\components\\icon.tsx":"7","C:\\Users\\lucas\\OneDrive\\Desktop\\GitHubProject\\typescript-porfolio-SP\\my-app\\src\\components\\layout\\particlesjs-config.js":"8","C:\\Users\\lucas\\OneDrive\\Desktop\\GitHubProject\\typescript-porfolio-SP\\my-app\\src\\components\\layout\\sidebar.tsx":"9","C:\\Users\\lucas\\OneDrive\\Desktop\\GitHubProject\\typescript-porfolio-SP\\my-app\\src\\components\\particles.jsx":"10","C:\\Users\\lucas\\OneDrive\\Desktop\\GitHubProject\\typescript-porfolio-SP\\my-app\\src\\pages\\skills.tsx":"11","C:\\Users\\lucas\\OneDrive\\Desktop\\GitHubProject\\typescript-porfolio-SP\\my-app\\src\\pages\\home.tsx":"12","C:\\Users\\lucas\\OneDrive\\Desktop\\GitHubProject\\typescript-porfolio-SP\\my-app\\src\\components\\layout\\pageLayout.tsx":"13"},{"size":515,"mtime":1610231461475,"results":"14","hashOfConfig":"15"},{"size":52532,"mtime":1610143555462,"results":"16","hashOfConfig":"15"},{"size":26456,"mtime":1610143679043,"results":"17","hashOfConfig":"15"},{"size":797,"mtime":1610229222291,"results":"18","hashOfConfig":"15"},{"size":555,"mtime":1610205970320,"results":"19","hashOfConfig":"15"},{"size":1676,"mtime":1610213721519,"results":"20","hashOfConfig":"15"},{"size":420,"mtime":1610232942672,"results":"21","hashOfConfig":"15"},{"size":2711,"mtime":1610227383790,"results":"22","hashOfConfig":"15"},{"size":2554,"mtime":1610232267307,"results":"23","hashOfConfig":"15"},{"size":537,"mtime":1610232651919,"results":"24","hashOfConfig":"15"},{"size":118,"mtime":1610229454161,"results":"25","hashOfConfig":"15"},{"size":393,"mtime":1610231099956,"results":"26","hashOfConfig":"15"},{"size":545,"mtime":1610231367575,"results":"27","hashOfConfig":"15"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"6oqvaz",{"filePath":"30","messages":"31","errorCount":0,"warningCount":70,"fixableErrorCount":0,"fixableWarningCount":0,"source":"32"},{"filePath":"33","messages":"34","errorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"35","messages":"36","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"37","messages":"38","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"39","messages":"40","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"41"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"44","messages":"45","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"46","messages":"47","errorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"48","messages":"49","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"50","messages":"51","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"52","messages":"53","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"54","messages":"55","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"C:\\Users\\lucas\\OneDrive\\Desktop\\GitHubProject\\typescript-porfolio-SP\\my-app\\src\\App.tsx",["56","57","58"],"C:\\Users\\lucas\\OneDrive\\Desktop\\GitHubProject\\typescript-porfolio-SP\\my-app\\src\\utils\\SVGLoader.js",["59","60","61","62","63","64","65","66","67","68","69","70","71","72","73","74","75","76","77","78","79","80","81","82","83","84","85","86","87","88","89","90","91","92","93","94","95","96","97","98","99","100","101","102","103","104","105","106","107","108","109","110","111","112","113","114","115","116","117","118","119","120","121","122","123","124","125","126","127","128"],"import {\r\n\tBufferGeometry,\r\n\tFileLoader,\r\n\tFloat32BufferAttribute,\r\n\tLoader,\r\n\tMatrix3,\r\n\tPath,\r\n\tShapePath,\r\n\tVector2,\r\n\tVector3\r\n} from 'three';\r\n\r\nvar SVGLoader = function ( manager ) {\r\n\r\n\tLoader.call( this, manager );\r\n\r\n\t// Default dots per inch\r\n\tthis.defaultDPI = 90;\r\n\r\n\t// Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'\r\n\tthis.defaultUnit = 'px';\r\n\r\n};\r\n\r\nSVGLoader.prototype = Object.assign( Object.create( Loader.prototype ), {\r\n\r\n\tconstructor: SVGLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new FileLoader( scope.manager );\r\n\t\tloader.setPath( scope.path );\r\n\t\tloader.setRequestHeader( scope.requestHeader );\r\n\t\tloader.setWithCredentials( scope.withCredentials );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\ttry {\r\n\r\n\t\t\t\tonLoad( scope.parse( text ) );\r\n\r\n\t\t\t} catch ( e ) {\r\n\r\n\t\t\t\tif ( onError ) {\r\n\r\n\t\t\t\t\tonError( e );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.error( e );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tscope.manager.itemError( url );\r\n\r\n\t\t\t}\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tparse: function ( text ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tfunction parseNode( node, style ) {\r\n\r\n\t\t\tif ( node.nodeType !== 1 ) return;\r\n\r\n\t\t\tvar transform = getNodeTransform( node );\r\n\r\n\t\t\tvar traverseChildNodes = true;\r\n\r\n\t\t\tvar path = null;\r\n\r\n\t\t\tswitch ( node.nodeName ) {\r\n\r\n\t\t\t\tcase 'svg':\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'style':\r\n\t\t\t\t\tparseCSSStylesheet( node );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'g':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'path':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\t\t\t\t\tif ( node.hasAttribute( 'd' ) ) path = parsePathNode( node );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'rect':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\t\t\t\t\tpath = parseRectNode( node );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'polygon':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\t\t\t\t\tpath = parsePolygonNode( node );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'polyline':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\t\t\t\t\tpath = parsePolylineNode( node );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'circle':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\t\t\t\t\tpath = parseCircleNode( node );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'ellipse':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\t\t\t\t\tpath = parseEllipseNode( node );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'line':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\t\t\t\t\tpath = parseLineNode( node );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'defs':\r\n\t\t\t\t\ttraverseChildNodes = false;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'use':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\t\t\t\t\tvar usedNodeId = node.href.baseVal.substring( 1 );\r\n\t\t\t\t\tvar usedNode = node.viewportElement.getElementById( usedNodeId );\r\n\t\t\t\t\tif ( usedNode ) {\r\n\r\n\t\t\t\t\t\tparseNode( usedNode, style );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tconsole.warn( 'SVGLoader: \\'use node\\' references non-existent node id: ' + usedNodeId );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\t// console.log( node );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( path ) {\r\n\r\n\t\t\t\tif ( style.fill !== undefined && style.fill !== 'none' ) {\r\n\r\n\t\t\t\t\tpath.color.setStyle( style.fill );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttransformPath( path, currentTransform );\r\n\r\n\t\t\t\tpaths.push( path );\r\n\r\n\t\t\t\tpath.userData = { node: node, style: style };\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( traverseChildNodes ) {\r\n\r\n\t\t\t\tvar nodes = node.childNodes;\r\n\r\n\t\t\t\tfor ( var i = 0; i < nodes.length; i ++ ) {\r\n\r\n\t\t\t\t\tparseNode( nodes[ i ], style );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( transform ) {\r\n\r\n\t\t\t\ttransformStack.pop();\r\n\r\n\t\t\t\tif ( transformStack.length > 0 ) {\r\n\r\n\t\t\t\t\tcurrentTransform.copy( transformStack[ transformStack.length - 1 ] );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tcurrentTransform.identity();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction parsePathNode( node ) {\r\n\r\n\t\t\tvar path = new ShapePath();\r\n\r\n\t\t\tvar point = new Vector2();\r\n\t\t\tvar control = new Vector2();\r\n\r\n\t\t\tvar firstPoint = new Vector2();\r\n\t\t\tvar isFirstPoint = true;\r\n\t\t\tvar doSetFirstPoint = false;\r\n\r\n\t\t\tvar d = node.getAttribute( 'd' );\r\n\r\n\t\t\t// console.log( d );\r\n\r\n\t\t\tvar commands = d.match( /[a-df-z][^a-df-z]*/ig );\r\n\r\n\t\t\tfor ( var i = 0, l = commands.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar command = commands[ i ];\r\n\r\n\t\t\t\tvar type = command.charAt( 0 );\r\n\t\t\t\tvar data = command.substr( 1 ).trim();\r\n\r\n\t\t\t\tif ( isFirstPoint === true ) {\r\n\r\n\t\t\t\t\tdoSetFirstPoint = true;\r\n\t\t\t\t\tisFirstPoint = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tswitch ( type ) {\r\n\r\n\t\t\t\t\tcase 'M':\r\n\t\t\t\t\t\tvar numbers = parseFloats( data );\r\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\r\n\r\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 ) {\r\n\r\n\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'H':\r\n\t\t\t\t\t\tvar numbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tpoint.x = numbers[ j ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'V':\r\n\t\t\t\t\t\tvar numbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tpoint.y = numbers[ j ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'L':\r\n\t\t\t\t\t\tvar numbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\r\n\r\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'C':\r\n\t\t\t\t\t\tvar numbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 6 ) {\r\n\r\n\t\t\t\t\t\t\tpath.bezierCurveTo(\r\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 4 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 5 ]\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 2 ];\r\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 3 ];\r\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 4 ];\r\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 5 ];\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'S':\r\n\t\t\t\t\t\tvar numbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\r\n\r\n\t\t\t\t\t\t\tpath.bezierCurveTo(\r\n\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\r\n\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\r\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\r\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\r\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'Q':\r\n\t\t\t\t\t\tvar numbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\r\n\r\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\r\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\r\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\r\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'T':\r\n\t\t\t\t\t\tvar numbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\r\n\r\n\t\t\t\t\t\t\tvar rx = getReflection( point.x, control.x );\r\n\t\t\t\t\t\t\tvar ry = getReflection( point.y, control.y );\r\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\r\n\t\t\t\t\t\t\t\trx,\r\n\t\t\t\t\t\t\t\try,\r\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ]\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tcontrol.x = rx;\r\n\t\t\t\t\t\t\tcontrol.y = ry;\r\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'A':\r\n\t\t\t\t\t\tvar numbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 7 ) {\r\n\r\n\t\t\t\t\t\t\t// skip command if start point == end point\r\n\t\t\t\t\t\t\tif ( numbers[ j + 5 ] == point.x && numbers[ j + 6 ] == point.y ) continue;\r\n\r\n\t\t\t\t\t\t\tvar start = point.clone();\r\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 5 ];\r\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 6 ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\t\t\t\t\t\t\tparseArcCommand(\r\n\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\r\n\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'm':\r\n\t\t\t\t\t\tvar numbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\r\n\r\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 ) {\r\n\r\n\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'h':\r\n\t\t\t\t\t\tvar numbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tpoint.x += numbers[ j ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'v':\r\n\t\t\t\t\t\tvar numbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tpoint.y += numbers[ j ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'l':\r\n\t\t\t\t\t\tvar numbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\r\n\r\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'c':\r\n\t\t\t\t\t\tvar numbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 6 ) {\r\n\r\n\t\t\t\t\t\t\tpath.bezierCurveTo(\r\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\r\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\r\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\r\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ],\r\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 4 ],\r\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 5 ]\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 2 ];\r\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 3 ];\r\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 4 ];\r\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 5 ];\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 's':\r\n\t\t\t\t\t\tvar numbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\r\n\r\n\t\t\t\t\t\t\tpath.bezierCurveTo(\r\n\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\r\n\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\r\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\r\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\r\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\r\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\r\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\r\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'q':\r\n\t\t\t\t\t\tvar numbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\r\n\r\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\r\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\r\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\r\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\r\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\r\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\r\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 't':\r\n\t\t\t\t\t\tvar numbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\r\n\r\n\t\t\t\t\t\t\tvar rx = getReflection( point.x, control.x );\r\n\t\t\t\t\t\t\tvar ry = getReflection( point.y, control.y );\r\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\r\n\t\t\t\t\t\t\t\trx,\r\n\t\t\t\t\t\t\t\try,\r\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\r\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ]\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tcontrol.x = rx;\r\n\t\t\t\t\t\t\tcontrol.y = ry;\r\n\t\t\t\t\t\t\tpoint.x = point.x + numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tpoint.y = point.y + numbers[ j + 1 ];\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'a':\r\n\t\t\t\t\t\tvar numbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 7 ) {\r\n\r\n\t\t\t\t\t\t\t// skip command if no displacement\r\n\t\t\t\t\t\t\tif ( numbers[ j + 5 ] == 0 && numbers[ j + 6 ] == 0 ) continue;\r\n\r\n\t\t\t\t\t\t\tvar start = point.clone();\r\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 5 ];\r\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 6 ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\t\t\t\t\t\t\tparseArcCommand(\r\n\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\r\n\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'Z':\r\n\t\t\t\t\tcase 'z':\r\n\t\t\t\t\t\tpath.currentPath.autoClose = true;\r\n\r\n\t\t\t\t\t\tif ( path.currentPath.curves.length > 0 ) {\r\n\r\n\t\t\t\t\t\t\t// Reset point to beginning of Path\r\n\t\t\t\t\t\t\tpoint.copy( firstPoint );\r\n\t\t\t\t\t\t\tpath.currentPath.currentPoint.copy( point );\r\n\t\t\t\t\t\t\tisFirstPoint = true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tconsole.warn( command );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// console.log( type, parseFloats( data ), parseFloats( data ).length  )\r\n\r\n\t\t\t\tdoSetFirstPoint = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn path;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseCSSStylesheet( node ) {\r\n\r\n\t\t\tif ( ! node.sheet || ! node.sheet.cssRules || ! node.sheet.cssRules.length ) return;\r\n\r\n\t\t\tfor ( var i = 0; i < node.sheet.cssRules.length; i ++ ) {\r\n\r\n\t\t\t\tvar stylesheet = node.sheet.cssRules[ i ];\r\n\r\n\t\t\t\tif ( stylesheet.type !== 1 ) continue;\r\n\r\n\t\t\t\tvar selectorList = stylesheet.selectorText\r\n\t\t\t\t\t.split( /,/gm )\r\n\t\t\t\t\t.filter( Boolean )\r\n\t\t\t\t\t.map( i => i.trim() );\r\n\r\n\t\t\t\tfor ( var j = 0; j < selectorList.length; j ++ ) {\r\n\r\n\t\t\t\t\tstylesheets[ selectorList[ j ] ] = Object.assign(\r\n\t\t\t\t\t\tstylesheets[ selectorList[ j ] ] || {},\r\n\t\t\t\t\t\tstylesheet.style\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\r\n\t\t * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\r\n\t\t * From\r\n\t\t * rx ry x-axis-rotation large-arc-flag sweep-flag x y\r\n\t\t * To\r\n\t\t * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\r\n\t\t */\r\n\r\n\t\tfunction parseArcCommand( path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end ) {\r\n\r\n\t\t\tif ( rx == 0 || ry == 0 ) {\r\n\r\n\t\t\t\t// draw a line if either of the radii == 0\r\n\t\t\t\tpath.lineTo( end.x, end.y );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tx_axis_rotation = x_axis_rotation * Math.PI / 180;\r\n\r\n\t\t\t// Ensure radii are positive\r\n\t\t\trx = Math.abs( rx );\r\n\t\t\try = Math.abs( ry );\r\n\r\n\t\t\t// Compute (x1', y1')\r\n\t\t\tvar dx2 = ( start.x - end.x ) / 2.0;\r\n\t\t\tvar dy2 = ( start.y - end.y ) / 2.0;\r\n\t\t\tvar x1p = Math.cos( x_axis_rotation ) * dx2 + Math.sin( x_axis_rotation ) * dy2;\r\n\t\t\tvar y1p = - Math.sin( x_axis_rotation ) * dx2 + Math.cos( x_axis_rotation ) * dy2;\r\n\r\n\t\t\t// Compute (cx', cy')\r\n\t\t\tvar rxs = rx * rx;\r\n\t\t\tvar rys = ry * ry;\r\n\t\t\tvar x1ps = x1p * x1p;\r\n\t\t\tvar y1ps = y1p * y1p;\r\n\r\n\t\t\t// Ensure radii are large enough\r\n\t\t\tvar cr = x1ps / rxs + y1ps / rys;\r\n\r\n\t\t\tif ( cr > 1 ) {\r\n\r\n\t\t\t\t// scale up rx,ry equally so cr == 1\r\n\t\t\t\tvar s = Math.sqrt( cr );\r\n\t\t\t\trx = s * rx;\r\n\t\t\t\try = s * ry;\r\n\t\t\t\trxs = rx * rx;\r\n\t\t\t\trys = ry * ry;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar dq = ( rxs * y1ps + rys * x1ps );\r\n\t\t\tvar pq = ( rxs * rys - dq ) / dq;\r\n\t\t\tvar q = Math.sqrt( Math.max( 0, pq ) );\r\n\t\t\tif ( large_arc_flag === sweep_flag ) q = - q;\r\n\t\t\tvar cxp = q * rx * y1p / ry;\r\n\t\t\tvar cyp = - q * ry * x1p / rx;\r\n\r\n\t\t\t// Step 3: Compute (cx, cy) from (cx', cy')\r\n\t\t\tvar cx = Math.cos( x_axis_rotation ) * cxp - Math.sin( x_axis_rotation ) * cyp + ( start.x + end.x ) / 2;\r\n\t\t\tvar cy = Math.sin( x_axis_rotation ) * cxp + Math.cos( x_axis_rotation ) * cyp + ( start.y + end.y ) / 2;\r\n\r\n\t\t\t// Step 4: Compute θ1 and Δθ\r\n\t\t\tvar theta = svgAngle( 1, 0, ( x1p - cxp ) / rx, ( y1p - cyp ) / ry );\r\n\t\t\tvar delta = svgAngle( ( x1p - cxp ) / rx, ( y1p - cyp ) / ry, ( - x1p - cxp ) / rx, ( - y1p - cyp ) / ry ) % ( Math.PI * 2 );\r\n\r\n\t\t\tpath.currentPath.absellipse( cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation );\r\n\r\n\t\t}\r\n\r\n\t\tfunction svgAngle( ux, uy, vx, vy ) {\r\n\r\n\t\t\tvar dot = ux * vx + uy * vy;\r\n\t\t\tvar len = Math.sqrt( ux * ux + uy * uy ) * Math.sqrt( vx * vx + vy * vy );\r\n\t\t\tvar ang = Math.acos( Math.max( - 1, Math.min( 1, dot / len ) ) ); // floating point precision, slightly over values appear\r\n\t\t\tif ( ( ux * vy - uy * vx ) < 0 ) ang = - ang;\r\n\t\t\treturn ang;\r\n\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t* According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\r\n\t\t* rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\r\n\t\t*/\r\n\t\tfunction parseRectNode( node ) {\r\n\r\n\t\t\tvar x = parseFloatWithUnits( node.getAttribute( 'x' ) || 0 );\r\n\t\t\tvar y = parseFloatWithUnits( node.getAttribute( 'y' ) || 0 );\r\n\t\t\tvar rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || 0 );\r\n\t\t\tvar ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || 0 );\r\n\t\t\tvar w = parseFloatWithUnits( node.getAttribute( 'width' ) );\r\n\t\t\tvar h = parseFloatWithUnits( node.getAttribute( 'height' ) );\r\n\r\n\t\t\tvar path = new ShapePath();\r\n\t\t\tpath.moveTo( x + 2 * rx, y );\r\n\t\t\tpath.lineTo( x + w - 2 * rx, y );\r\n\t\t\tif ( rx !== 0 || ry !== 0 ) path.bezierCurveTo( x + w, y, x + w, y, x + w, y + 2 * ry );\r\n\t\t\tpath.lineTo( x + w, y + h - 2 * ry );\r\n\t\t\tif ( rx !== 0 || ry !== 0 ) path.bezierCurveTo( x + w, y + h, x + w, y + h, x + w - 2 * rx, y + h );\r\n\t\t\tpath.lineTo( x + 2 * rx, y + h );\r\n\r\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\r\n\r\n\t\t\t\tpath.bezierCurveTo( x, y + h, x, y + h, x, y + h - 2 * ry );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tpath.lineTo( x, y + 2 * ry );\r\n\r\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\r\n\r\n\t\t\t\tpath.bezierCurveTo( x, y, x, y, x + 2 * rx, y );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn path;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parsePolygonNode( node ) {\r\n\r\n\t\t\tfunction iterator( match, a, b ) {\r\n\r\n\t\t\t\tvar x = parseFloatWithUnits( a );\r\n\t\t\t\tvar y = parseFloatWithUnits( b );\r\n\r\n\t\t\t\tif ( index === 0 ) {\r\n\r\n\t\t\t\t\tpath.moveTo( x, y );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tpath.lineTo( x, y );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tindex ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\r\n\r\n\t\t\tvar path = new ShapePath();\r\n\r\n\t\t\tvar index = 0;\r\n\r\n\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\r\n\r\n\t\t\tpath.currentPath.autoClose = true;\r\n\r\n\t\t\treturn path;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parsePolylineNode( node ) {\r\n\r\n\t\t\tfunction iterator( match, a, b ) {\r\n\r\n\t\t\t\tvar x = parseFloatWithUnits( a );\r\n\t\t\t\tvar y = parseFloatWithUnits( b );\r\n\r\n\t\t\t\tif ( index === 0 ) {\r\n\r\n\t\t\t\t\tpath.moveTo( x, y );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tpath.lineTo( x, y );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tindex ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\r\n\r\n\t\t\tvar path = new ShapePath();\r\n\r\n\t\t\tvar index = 0;\r\n\r\n\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\r\n\r\n\t\t\tpath.currentPath.autoClose = false;\r\n\r\n\t\t\treturn path;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseCircleNode( node ) {\r\n\r\n\t\t\tvar x = parseFloatWithUnits( node.getAttribute( 'cx' ) );\r\n\t\t\tvar y = parseFloatWithUnits( node.getAttribute( 'cy' ) );\r\n\t\t\tvar r = parseFloatWithUnits( node.getAttribute( 'r' ) );\r\n\r\n\t\t\tvar subpath = new Path();\r\n\t\t\tsubpath.absarc( x, y, r, 0, Math.PI * 2 );\r\n\r\n\t\t\tvar path = new ShapePath();\r\n\t\t\tpath.subPaths.push( subpath );\r\n\r\n\t\t\treturn path;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseEllipseNode( node ) {\r\n\r\n\t\t\tvar x = parseFloatWithUnits( node.getAttribute( 'cx' ) );\r\n\t\t\tvar y = parseFloatWithUnits( node.getAttribute( 'cy' ) );\r\n\t\t\tvar rx = parseFloatWithUnits( node.getAttribute( 'rx' ) );\r\n\t\t\tvar ry = parseFloatWithUnits( node.getAttribute( 'ry' ) );\r\n\r\n\t\t\tvar subpath = new Path();\r\n\t\t\tsubpath.absellipse( x, y, rx, ry, 0, Math.PI * 2 );\r\n\r\n\t\t\tvar path = new ShapePath();\r\n\t\t\tpath.subPaths.push( subpath );\r\n\r\n\t\t\treturn path;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseLineNode( node ) {\r\n\r\n\t\t\tvar x1 = parseFloatWithUnits( node.getAttribute( 'x1' ) );\r\n\t\t\tvar y1 = parseFloatWithUnits( node.getAttribute( 'y1' ) );\r\n\t\t\tvar x2 = parseFloatWithUnits( node.getAttribute( 'x2' ) );\r\n\t\t\tvar y2 = parseFloatWithUnits( node.getAttribute( 'y2' ) );\r\n\r\n\t\t\tvar path = new ShapePath();\r\n\t\t\tpath.moveTo( x1, y1 );\r\n\t\t\tpath.lineTo( x2, y2 );\r\n\t\t\tpath.currentPath.autoClose = false;\r\n\r\n\t\t\treturn path;\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tfunction parseStyle( node, style ) {\r\n\r\n\t\t\tstyle = Object.assign( {}, style ); // clone style\r\n\r\n\t\t\tvar stylesheetStyles = {};\r\n\r\n\t\t\tif ( node.hasAttribute( 'class' ) ) {\r\n\r\n\t\t\t\tvar classSelectors = node.getAttribute( 'class' )\r\n\t\t\t\t\t.split( /\\s/ )\r\n\t\t\t\t\t.filter( Boolean )\r\n\t\t\t\t\t.map( i => i.trim() );\r\n\r\n\t\t\t\tfor ( var i = 0; i < classSelectors.length; i ++ ) {\r\n\r\n\t\t\t\t\tstylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '.' + classSelectors[ i ] ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( node.hasAttribute( 'id' ) ) {\r\n\r\n\t\t\t\tstylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '#' + node.getAttribute( 'id' ) ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction addStyle( svgName, jsName, adjustFunction ) {\r\n\r\n\t\t\t\tif ( adjustFunction === undefined ) adjustFunction = function copy( v ) {\r\n\r\n\t\t\t\t\tif ( v.startsWith( 'url' ) ) console.warn( 'SVGLoader: url access in attributes is not implemented.' );\r\n\r\n\t\t\t\t\treturn v;\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t\tif ( node.hasAttribute( svgName ) ) style[ jsName ] = adjustFunction( node.getAttribute( svgName ) );\r\n\t\t\t\tif ( stylesheetStyles[ svgName ] ) style[ jsName ] = adjustFunction( stylesheetStyles[ svgName ] );\r\n\t\t\t\tif ( node.style && node.style[ svgName ] !== '' ) style[ jsName ] = adjustFunction( node.style[ svgName ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction clamp( v ) {\r\n\r\n\t\t\t\treturn Math.max( 0, Math.min( 1, parseFloatWithUnits( v ) ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction positive( v ) {\r\n\r\n\t\t\t\treturn Math.max( 0, parseFloatWithUnits( v ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\taddStyle( 'fill', 'fill' );\r\n\t\t\taddStyle( 'fill-opacity', 'fillOpacity', clamp );\r\n\t\t\taddStyle( 'opacity', 'opacity', clamp );\r\n\t\t\taddStyle( 'stroke', 'stroke' );\r\n\t\t\taddStyle( 'stroke-opacity', 'strokeOpacity', clamp );\r\n\t\t\taddStyle( 'stroke-width', 'strokeWidth', positive );\r\n\t\t\taddStyle( 'stroke-linejoin', 'strokeLineJoin' );\r\n\t\t\taddStyle( 'stroke-linecap', 'strokeLineCap' );\r\n\t\t\taddStyle( 'stroke-miterlimit', 'strokeMiterLimit', positive );\r\n\t\t\taddStyle( 'visibility', 'visibility' );\r\n\r\n\t\t\treturn style;\r\n\r\n\t\t}\r\n\r\n\t\t// http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\r\n\r\n\t\tfunction getReflection( a, b ) {\r\n\r\n\t\t\treturn a - ( b - a );\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseFloats( string ) {\r\n\r\n\t\t\tvar array = string.split( /[\\s,]+|(?=\\s?[+\\-])/ );\r\n\r\n\t\t\tfor ( var i = 0; i < array.length; i ++ ) {\r\n\r\n\t\t\t\tvar number = array[ i ];\r\n\r\n\t\t\t\t// Handle values like 48.6037.7.8\r\n\t\t\t\t// TODO Find a regex for this\r\n\r\n\t\t\t\tif ( number.indexOf( '.' ) !== number.lastIndexOf( '.' ) ) {\r\n\r\n\t\t\t\t\tvar split = number.split( '.' );\r\n\r\n\t\t\t\t\tfor ( var s = 2; s < split.length; s ++ ) {\r\n\r\n\t\t\t\t\t\tarray.splice( i + s - 1, 0, '0.' + split[ s ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tarray[ i ] = parseFloatWithUnits( number );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn array;\r\n\r\n\r\n\t\t}\r\n\r\n\t\t// Units\r\n\r\n\t\tvar units = [ 'mm', 'cm', 'in', 'pt', 'pc', 'px' ];\r\n\r\n\t\t// Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)\r\n\t\tvar unitConversion = {\r\n\r\n\t\t\t'mm': {\r\n\t\t\t\t'mm': 1,\r\n\t\t\t\t'cm': 0.1,\r\n\t\t\t\t'in': 1 / 25.4,\r\n\t\t\t\t'pt': 72 / 25.4,\r\n\t\t\t\t'pc': 6 / 25.4,\r\n\t\t\t\t'px': - 1\r\n\t\t\t},\r\n\t\t\t'cm': {\r\n\t\t\t\t'mm': 10,\r\n\t\t\t\t'cm': 1,\r\n\t\t\t\t'in': 1 / 2.54,\r\n\t\t\t\t'pt': 72 / 2.54,\r\n\t\t\t\t'pc': 6 / 2.54,\r\n\t\t\t\t'px': - 1\r\n\t\t\t},\r\n\t\t\t'in': {\r\n\t\t\t\t'mm': 25.4,\r\n\t\t\t\t'cm': 2.54,\r\n\t\t\t\t'in': 1,\r\n\t\t\t\t'pt': 72,\r\n\t\t\t\t'pc': 6,\r\n\t\t\t\t'px': - 1\r\n\t\t\t},\r\n\t\t\t'pt': {\r\n\t\t\t\t'mm': 25.4 / 72,\r\n\t\t\t\t'cm': 2.54 / 72,\r\n\t\t\t\t'in': 1 / 72,\r\n\t\t\t\t'pt': 1,\r\n\t\t\t\t'pc': 6 / 72,\r\n\t\t\t\t'px': - 1\r\n\t\t\t},\r\n\t\t\t'pc': {\r\n\t\t\t\t'mm': 25.4 / 6,\r\n\t\t\t\t'cm': 2.54 / 6,\r\n\t\t\t\t'in': 1 / 6,\r\n\t\t\t\t'pt': 72 / 6,\r\n\t\t\t\t'pc': 1,\r\n\t\t\t\t'px': - 1\r\n\t\t\t},\r\n\t\t\t'px': {\r\n\t\t\t\t'px': 1\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tfunction parseFloatWithUnits( string ) {\r\n\r\n\t\t\tvar theUnit = 'px';\r\n\r\n\t\t\tif ( typeof string === 'string' || string instanceof String ) {\r\n\r\n\t\t\t\tfor ( var i = 0, n = units.length; i < n; i ++ ) {\r\n\r\n\t\t\t\t\tvar u = units[ i ];\r\n\r\n\t\t\t\t\tif ( string.endsWith( u ) ) {\r\n\r\n\t\t\t\t\t\ttheUnit = u;\r\n\t\t\t\t\t\tstring = string.substring( 0, string.length - u.length );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar scale = undefined;\r\n\r\n\t\t\tif ( theUnit === 'px' && scope.defaultUnit !== 'px' ) {\r\n\r\n\t\t\t\t// Conversion scale from  pixels to inches, then to default units\r\n\r\n\t\t\t\tscale = unitConversion[ 'in' ][ scope.defaultUnit ] / scope.defaultDPI;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tscale = unitConversion[ theUnit ][ scope.defaultUnit ];\r\n\r\n\t\t\t\tif ( scale < 0 ) {\r\n\r\n\t\t\t\t\t// Conversion scale to pixels\r\n\r\n\t\t\t\t\tscale = unitConversion[ theUnit ][ 'in' ] * scope.defaultDPI;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn scale * parseFloat( string );\r\n\r\n\t\t}\r\n\r\n\t\t// Transforms\r\n\r\n\t\tfunction getNodeTransform( node ) {\r\n\r\n\t\t\tif ( ! ( node.hasAttribute( 'transform' ) || ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) ) ) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar transform = parseNodeTransform( node );\r\n\r\n\t\t\tif ( transformStack.length > 0 ) {\r\n\r\n\t\t\t\ttransform.premultiply( transformStack[ transformStack.length - 1 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcurrentTransform.copy( transform );\r\n\t\t\ttransformStack.push( transform );\r\n\r\n\t\t\treturn transform;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseNodeTransform( node ) {\r\n\r\n\t\t\tvar transform = new Matrix3();\r\n\t\t\tvar currentTransform = tempTransform0;\r\n\r\n\t\t\tif ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) {\r\n\r\n\t\t\t\tvar tx = parseFloatWithUnits( node.getAttribute( 'x' ) );\r\n\t\t\t\tvar ty = parseFloatWithUnits( node.getAttribute( 'y' ) );\r\n\r\n\t\t\t\ttransform.translate( tx, ty );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( node.hasAttribute( 'transform' ) ) {\r\n\r\n\t\t\t\tvar transformsTexts = node.getAttribute( 'transform' ).split( ')' );\r\n\r\n\t\t\t\tfor ( var tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex -- ) {\r\n\r\n\t\t\t\t\tvar transformText = transformsTexts[ tIndex ].trim();\r\n\r\n\t\t\t\t\tif ( transformText === '' ) continue;\r\n\r\n\t\t\t\t\tvar openParPos = transformText.indexOf( '(' );\r\n\t\t\t\t\tvar closeParPos = transformText.length;\r\n\r\n\t\t\t\t\tif ( openParPos > 0 && openParPos < closeParPos ) {\r\n\r\n\t\t\t\t\t\tvar transformType = transformText.substr( 0, openParPos );\r\n\r\n\t\t\t\t\t\tvar array = parseFloats( transformText.substr( openParPos + 1, closeParPos - openParPos - 1 ) );\r\n\r\n\t\t\t\t\t\tcurrentTransform.identity();\r\n\r\n\t\t\t\t\t\tswitch ( transformType ) {\r\n\r\n\t\t\t\t\t\t\tcase 'translate':\r\n\r\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\r\n\r\n\t\t\t\t\t\t\t\t\tvar tx = array[ 0 ];\r\n\t\t\t\t\t\t\t\t\tvar ty = tx;\r\n\r\n\t\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tty = array[ 1 ];\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\tcurrentTransform.translate( tx, ty );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 'rotate':\r\n\r\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\r\n\r\n\t\t\t\t\t\t\t\t\tvar angle = 0;\r\n\t\t\t\t\t\t\t\t\tvar cx = 0;\r\n\t\t\t\t\t\t\t\t\tvar cy = 0;\r\n\r\n\t\t\t\t\t\t\t\t\t// Angle\r\n\t\t\t\t\t\t\t\t\tangle = - array[ 0 ] * Math.PI / 180;\r\n\r\n\t\t\t\t\t\t\t\t\tif ( array.length >= 3 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Center x, y\r\n\t\t\t\t\t\t\t\t\t\tcx = array[ 1 ];\r\n\t\t\t\t\t\t\t\t\t\tcy = array[ 2 ];\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t// Rotate around center (cx, cy)\r\n\t\t\t\t\t\t\t\t\ttempTransform1.identity().translate( - cx, - cy );\r\n\t\t\t\t\t\t\t\t\ttempTransform2.identity().rotate( angle );\r\n\t\t\t\t\t\t\t\t\ttempTransform3.multiplyMatrices( tempTransform2, tempTransform1 );\r\n\t\t\t\t\t\t\t\t\ttempTransform1.identity().translate( cx, cy );\r\n\t\t\t\t\t\t\t\t\tcurrentTransform.multiplyMatrices( tempTransform1, tempTransform3 );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 'scale':\r\n\r\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\r\n\r\n\t\t\t\t\t\t\t\t\tvar scaleX = array[ 0 ];\r\n\t\t\t\t\t\t\t\t\tvar scaleY = scaleX;\r\n\r\n\t\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tscaleY = array[ 1 ];\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\tcurrentTransform.scale( scaleX, scaleY );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 'skewX':\r\n\r\n\t\t\t\t\t\t\t\tif ( array.length === 1 ) {\r\n\r\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\r\n\t\t\t\t\t\t\t\t\t\t1, Math.tan( array[ 0 ] * Math.PI / 180 ), 0,\r\n\t\t\t\t\t\t\t\t\t\t0, 1, 0,\r\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\r\n\t\t\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 'skewY':\r\n\r\n\t\t\t\t\t\t\t\tif ( array.length === 1 ) {\r\n\r\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\r\n\t\t\t\t\t\t\t\t\t\t1, 0, 0,\r\n\t\t\t\t\t\t\t\t\t\tMath.tan( array[ 0 ] * Math.PI / 180 ), 1, 0,\r\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\r\n\t\t\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 'matrix':\r\n\r\n\t\t\t\t\t\t\t\tif ( array.length === 6 ) {\r\n\r\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\r\n\t\t\t\t\t\t\t\t\t\tarray[ 0 ], array[ 2 ], array[ 4 ],\r\n\t\t\t\t\t\t\t\t\t\tarray[ 1 ], array[ 3 ], array[ 5 ],\r\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\r\n\t\t\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttransform.premultiply( currentTransform );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn transform;\r\n\r\n\t\t}\r\n\r\n\t\tfunction transformPath( path, m ) {\r\n\r\n\t\t\tfunction transfVec2( v2 ) {\r\n\r\n\t\t\t\ttempV3.set( v2.x, v2.y, 1 ).applyMatrix3( m );\r\n\r\n\t\t\t\tv2.set( tempV3.x, tempV3.y );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar isRotated = isTransformRotated( m );\r\n\r\n\t\t\tvar subPaths = path.subPaths;\r\n\r\n\t\t\tfor ( var i = 0, n = subPaths.length; i < n; i ++ ) {\r\n\r\n\t\t\t\tvar subPath = subPaths[ i ];\r\n\t\t\t\tvar curves = subPath.curves;\r\n\r\n\t\t\t\tfor ( var j = 0; j < curves.length; j ++ ) {\r\n\r\n\t\t\t\t\tvar curve = curves[ j ];\r\n\r\n\t\t\t\t\tif ( curve.isLineCurve ) {\r\n\r\n\t\t\t\t\t\ttransfVec2( curve.v1 );\r\n\t\t\t\t\t\ttransfVec2( curve.v2 );\r\n\r\n\t\t\t\t\t} else if ( curve.isCubicBezierCurve ) {\r\n\r\n\t\t\t\t\t\ttransfVec2( curve.v0 );\r\n\t\t\t\t\t\ttransfVec2( curve.v1 );\r\n\t\t\t\t\t\ttransfVec2( curve.v2 );\r\n\t\t\t\t\t\ttransfVec2( curve.v3 );\r\n\r\n\t\t\t\t\t} else if ( curve.isQuadraticBezierCurve ) {\r\n\r\n\t\t\t\t\t\ttransfVec2( curve.v0 );\r\n\t\t\t\t\t\ttransfVec2( curve.v1 );\r\n\t\t\t\t\t\ttransfVec2( curve.v2 );\r\n\r\n\t\t\t\t\t} else if ( curve.isEllipseCurve ) {\r\n\r\n\t\t\t\t\t\tif ( isRotated ) {\r\n\r\n\t\t\t\t\t\t\tconsole.warn( 'SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented.' );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\ttempV2.set( curve.aX, curve.aY );\r\n\t\t\t\t\t\ttransfVec2( tempV2 );\r\n\t\t\t\t\t\tcurve.aX = tempV2.x;\r\n\t\t\t\t\t\tcurve.aY = tempV2.y;\r\n\r\n\t\t\t\t\t\tcurve.xRadius *= getTransformScaleX( m );\r\n\t\t\t\t\t\tcurve.yRadius *= getTransformScaleY( m );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction isTransformRotated( m ) {\r\n\r\n\t\t\treturn m.elements[ 1 ] !== 0 || m.elements[ 3 ] !== 0;\r\n\r\n\t\t}\r\n\r\n\t\tfunction getTransformScaleX( m ) {\r\n\r\n\t\t\tvar te = m.elements;\r\n\t\t\treturn Math.sqrt( te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] );\r\n\r\n\t\t}\r\n\r\n\t\tfunction getTransformScaleY( m ) {\r\n\r\n\t\t\tvar te = m.elements;\r\n\t\t\treturn Math.sqrt( te[ 3 ] * te[ 3 ] + te[ 4 ] * te[ 4 ] );\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tvar paths = [];\r\n\t\tvar stylesheets = {};\r\n\r\n\t\tvar transformStack = [];\r\n\r\n\t\tvar tempTransform0 = new Matrix3();\r\n\t\tvar tempTransform1 = new Matrix3();\r\n\t\tvar tempTransform2 = new Matrix3();\r\n\t\tvar tempTransform3 = new Matrix3();\r\n\t\tvar tempV2 = new Vector2();\r\n\t\tvar tempV3 = new Vector3();\r\n\r\n\t\tvar currentTransform = new Matrix3();\r\n\r\n\t\tvar xml = new DOMParser().parseFromString( text, 'image/svg+xml' ); // application/xml\r\n\r\n\t\tparseNode( xml.documentElement, {\r\n\t\t\tfill: '#000',\r\n\t\t\tfillOpacity: 1,\r\n\t\t\tstrokeOpacity: 1,\r\n\t\t\tstrokeWidth: 1,\r\n\t\t\tstrokeLineJoin: 'miter',\r\n\t\t\tstrokeLineCap: 'butt',\r\n\t\t\tstrokeMiterLimit: 4\r\n\t\t} );\r\n\r\n\t\tvar data = { paths: paths, xml: xml.documentElement };\r\n\r\n\t\t// console.log( paths );\r\n\t\treturn data;\r\n\r\n\t}\r\n\r\n} );\r\n\r\nSVGLoader.getStrokeStyle = function ( width, color, lineJoin, lineCap, miterLimit ) {\r\n\r\n\t// Param width: Stroke width\r\n\t// Param color: As returned by THREE.Color.getStyle()\r\n\t// Param lineJoin: One of \"round\", \"bevel\", \"miter\" or \"miter-limit\"\r\n\t// Param lineCap: One of \"round\", \"square\" or \"butt\"\r\n\t// Param miterLimit: Maximum join length, in multiples of the \"width\" parameter (join is truncated if it exceeds that distance)\r\n\t// Returns style object\r\n\r\n\twidth = width !== undefined ? width : 1;\r\n\tcolor = color !== undefined ? color : '#000';\r\n\tlineJoin = lineJoin !== undefined ? lineJoin : 'miter';\r\n\tlineCap = lineCap !== undefined ? lineCap : 'butt';\r\n\tmiterLimit = miterLimit !== undefined ? miterLimit : 4;\r\n\r\n\treturn {\r\n\t\tstrokeColor: color,\r\n\t\tstrokeWidth: width,\r\n\t\tstrokeLineJoin: lineJoin,\r\n\t\tstrokeLineCap: lineCap,\r\n\t\tstrokeMiterLimit: miterLimit\r\n\t};\r\n\r\n};\r\n\r\nSVGLoader.pointsToStroke = function ( points, style, arcDivisions, minDistance ) {\r\n\r\n\t// Generates a stroke with some witdh around the given path.\r\n\t// The path can be open or closed (last point equals to first point)\r\n\t// Param points: Array of Vector2D (the path). Minimum 2 points.\r\n\t// Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object\r\n\t// Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)\r\n\t// Param minDistance: Points closer to this distance will be merged. (Optional)\r\n\t// Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)\r\n\r\n\tvar vertices = [];\r\n\tvar normals = [];\r\n\tvar uvs = [];\r\n\r\n\tif ( SVGLoader.pointsToStrokeWithBuffers( points, style, arcDivisions, minDistance, vertices, normals, uvs ) === 0 ) {\r\n\r\n\t\treturn null;\r\n\r\n\t}\r\n\r\n\tvar geometry = new BufferGeometry();\r\n\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\r\n\tgeometry.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\r\n\tgeometry.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\r\n\r\n\treturn geometry;\r\n\r\n};\r\n\r\nSVGLoader.pointsToStrokeWithBuffers = function () {\r\n\r\n\tvar tempV2_1 = new Vector2();\r\n\tvar tempV2_2 = new Vector2();\r\n\tvar tempV2_3 = new Vector2();\r\n\tvar tempV2_4 = new Vector2();\r\n\tvar tempV2_5 = new Vector2();\r\n\tvar tempV2_6 = new Vector2();\r\n\tvar tempV2_7 = new Vector2();\r\n\tvar lastPointL = new Vector2();\r\n\tvar lastPointR = new Vector2();\r\n\tvar point0L = new Vector2();\r\n\tvar point0R = new Vector2();\r\n\tvar currentPointL = new Vector2();\r\n\tvar currentPointR = new Vector2();\r\n\tvar nextPointL = new Vector2();\r\n\tvar nextPointR = new Vector2();\r\n\tvar innerPoint = new Vector2();\r\n\tvar outerPoint = new Vector2();\r\n\r\n\treturn function ( points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset ) {\r\n\r\n\t\t// This function can be called to update existing arrays or buffers.\r\n\t\t// Accepts same parameters as pointsToStroke, plus the buffers and optional offset.\r\n\t\t// Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)\r\n\t\t// Returns number of written vertices / normals / uvs pairs\r\n\t\t// if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)\r\n\t\t// 'normals' and 'uvs' buffers are optional\r\n\r\n\t\tarcDivisions = arcDivisions !== undefined ? arcDivisions : 12;\r\n\t\tminDistance = minDistance !== undefined ? minDistance : 0.001;\r\n\t\tvertexOffset = vertexOffset !== undefined ? vertexOffset : 0;\r\n\r\n\t\t// First ensure there are no duplicated points\r\n\t\tpoints = removeDuplicatedPoints( points );\r\n\r\n\t\tvar numPoints = points.length;\r\n\r\n\t\tif ( numPoints < 2 ) return 0;\r\n\r\n\t\tvar isClosed = points[ 0 ].equals( points[ numPoints - 1 ] );\r\n\r\n\t\tvar currentPoint;\r\n\t\tvar previousPoint = points[ 0 ];\r\n\t\tvar nextPoint;\r\n\r\n\t\tvar strokeWidth2 = style.strokeWidth / 2;\r\n\r\n\t\tvar deltaU = 1 / ( numPoints - 1 );\r\n\t\tvar u0 = 0;\r\n\r\n\t\tvar innerSideModified;\r\n\t\tvar joinIsOnLeftSide;\r\n\t\tvar isMiter;\r\n\t\tvar initialJoinIsOnLeftSide = false;\r\n\r\n\t\tvar numVertices = 0;\r\n\t\tvar currentCoordinate = vertexOffset * 3;\r\n\t\tvar currentCoordinateUV = vertexOffset * 2;\r\n\r\n\t\t// Get initial left and right stroke points\r\n\t\tgetNormal( points[ 0 ], points[ 1 ], tempV2_1 ).multiplyScalar( strokeWidth2 );\r\n\t\tlastPointL.copy( points[ 0 ] ).sub( tempV2_1 );\r\n\t\tlastPointR.copy( points[ 0 ] ).add( tempV2_1 );\r\n\t\tpoint0L.copy( lastPointL );\r\n\t\tpoint0R.copy( lastPointR );\r\n\r\n\t\tfor ( var iPoint = 1; iPoint < numPoints; iPoint ++ ) {\r\n\r\n\t\t\tcurrentPoint = points[ iPoint ];\r\n\r\n\t\t\t// Get next point\r\n\t\t\tif ( iPoint === numPoints - 1 ) {\r\n\r\n\t\t\t\tif ( isClosed ) {\r\n\r\n\t\t\t\t\t// Skip duplicated initial point\r\n\t\t\t\t\tnextPoint = points[ 1 ];\r\n\r\n\t\t\t\t} else nextPoint = undefined;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tnextPoint = points[ iPoint + 1 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Normal of previous segment in tempV2_1\r\n\t\t\tvar normal1 = tempV2_1;\r\n\t\t\tgetNormal( previousPoint, currentPoint, normal1 );\r\n\r\n\t\t\ttempV2_3.copy( normal1 ).multiplyScalar( strokeWidth2 );\r\n\t\t\tcurrentPointL.copy( currentPoint ).sub( tempV2_3 );\r\n\t\t\tcurrentPointR.copy( currentPoint ).add( tempV2_3 );\r\n\r\n\t\t\tvar u1 = u0 + deltaU;\r\n\r\n\t\t\tinnerSideModified = false;\r\n\r\n\t\t\tif ( nextPoint !== undefined ) {\r\n\r\n\t\t\t\t// Normal of next segment in tempV2_2\r\n\t\t\t\tgetNormal( currentPoint, nextPoint, tempV2_2 );\r\n\r\n\t\t\t\ttempV2_3.copy( tempV2_2 ).multiplyScalar( strokeWidth2 );\r\n\t\t\t\tnextPointL.copy( currentPoint ).sub( tempV2_3 );\r\n\t\t\t\tnextPointR.copy( currentPoint ).add( tempV2_3 );\r\n\r\n\t\t\t\tjoinIsOnLeftSide = true;\r\n\t\t\t\ttempV2_3.subVectors( nextPoint, previousPoint );\r\n\t\t\t\tif ( normal1.dot( tempV2_3 ) < 0 ) {\r\n\r\n\t\t\t\t\tjoinIsOnLeftSide = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( iPoint === 1 ) initialJoinIsOnLeftSide = joinIsOnLeftSide;\r\n\r\n\t\t\t\ttempV2_3.subVectors( nextPoint, currentPoint );\r\n\t\t\t\ttempV2_3.normalize();\r\n\t\t\t\tvar dot = Math.abs( normal1.dot( tempV2_3 ) );\r\n\r\n\t\t\t\t// If path is straight, don't create join\r\n\t\t\t\tif ( dot !== 0 ) {\r\n\r\n\t\t\t\t\t// Compute inner and outer segment intersections\r\n\t\t\t\t\tvar miterSide = strokeWidth2 / dot;\r\n\t\t\t\t\ttempV2_3.multiplyScalar( - miterSide );\r\n\t\t\t\t\ttempV2_4.subVectors( currentPoint, previousPoint );\r\n\t\t\t\t\ttempV2_5.copy( tempV2_4 ).setLength( miterSide ).add( tempV2_3 );\r\n\t\t\t\t\tinnerPoint.copy( tempV2_5 ).negate();\r\n\t\t\t\t\tvar miterLength2 = tempV2_5.length();\r\n\t\t\t\t\tvar segmentLengthPrev = tempV2_4.length();\r\n\t\t\t\t\ttempV2_4.divideScalar( segmentLengthPrev );\r\n\t\t\t\t\ttempV2_6.subVectors( nextPoint, currentPoint );\r\n\t\t\t\t\tvar segmentLengthNext = tempV2_6.length();\r\n\t\t\t\t\ttempV2_6.divideScalar( segmentLengthNext );\r\n\t\t\t\t\t// Check that previous and next segments doesn't overlap with the innerPoint of intersection\r\n\t\t\t\t\tif ( tempV2_4.dot( innerPoint ) < segmentLengthPrev && tempV2_6.dot( innerPoint ) < segmentLengthNext ) {\r\n\r\n\t\t\t\t\t\tinnerSideModified = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\touterPoint.copy( tempV2_5 ).add( currentPoint );\r\n\t\t\t\t\tinnerPoint.add( currentPoint );\r\n\r\n\t\t\t\t\tisMiter = false;\r\n\r\n\t\t\t\t\tif ( innerSideModified ) {\r\n\r\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\t\t\tnextPointR.copy( innerPoint );\r\n\t\t\t\t\t\t\tcurrentPointR.copy( innerPoint );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tnextPointL.copy( innerPoint );\r\n\t\t\t\t\t\t\tcurrentPointL.copy( innerPoint );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// The segment triangles are generated here if there was overlapping\r\n\r\n\t\t\t\t\t\tmakeSegmentTriangles();\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tswitch ( style.strokeLineJoin ) {\r\n\r\n\t\t\t\t\t\tcase 'bevel':\r\n\r\n\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'round':\r\n\r\n\t\t\t\t\t\t\t// Segment triangles\r\n\r\n\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\r\n\r\n\t\t\t\t\t\t\t// Join triangles\r\n\r\n\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, currentPointL, nextPointL, u1, 0 );\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, nextPointR, currentPointR, u1, 1 );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'miter':\r\n\t\t\t\t\t\tcase 'miter-clip':\r\n\t\t\t\t\t\tdefault:\r\n\r\n\t\t\t\t\t\t\tvar miterFraction = ( strokeWidth2 * style.strokeMiterLimit ) / miterLength2;\r\n\r\n\t\t\t\t\t\t\tif ( miterFraction < 1 ) {\r\n\r\n\t\t\t\t\t\t\t\t// The join miter length exceeds the miter limit\r\n\r\n\t\t\t\t\t\t\t\tif ( style.strokeLineJoin !== 'miter-clip' ) {\r\n\r\n\t\t\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\t// Segment triangles\r\n\r\n\t\t\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\r\n\r\n\t\t\t\t\t\t\t\t\t// Miter-clip join triangles\r\n\r\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointL ).multiplyScalar( miterFraction ).add( currentPointL );\r\n\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointL ).multiplyScalar( miterFraction ).add( nextPointL );\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\r\n\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointR ).multiplyScalar( miterFraction ).add( currentPointR );\r\n\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointR ).multiplyScalar( miterFraction ).add( nextPointR );\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t// Miter join segment triangles\r\n\r\n\t\t\t\t\t\t\t\tif ( innerSideModified ) {\r\n\r\n\t\t\t\t\t\t\t\t\t// Optimized segment + join triangles\r\n\r\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 1 );\r\n\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tnextPointL.copy( outerPoint );\r\n\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\t\tnextPointR.copy( outerPoint );\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\t// Add extra miter join triangles\r\n\r\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\r\n\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tisMiter = true;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// The segment triangles are generated here when two consecutive points are collinear\r\n\r\n\t\t\t\t\tmakeSegmentTriangles();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// The segment triangles are generated here if it is the ending segment\r\n\r\n\t\t\t\tmakeSegmentTriangles();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! isClosed && iPoint === numPoints - 1 ) {\r\n\r\n\t\t\t\t// Start line endcap\r\n\t\t\t\taddCapGeometry( points[ 0 ], point0L, point0R, joinIsOnLeftSide, true, u0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Increment loop variables\r\n\r\n\t\t\tu0 = u1;\r\n\r\n\t\t\tpreviousPoint = currentPoint;\r\n\r\n\t\t\tlastPointL.copy( nextPointL );\r\n\t\t\tlastPointR.copy( nextPointR );\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! isClosed ) {\r\n\r\n\t\t\t// Ending line endcap\r\n\t\t\taddCapGeometry( currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1 );\r\n\r\n\t\t} else if ( innerSideModified && vertices ) {\r\n\r\n\t\t\t// Modify path first segment vertices to adjust to the segments inner and outer intersections\r\n\r\n\t\t\tvar lastOuter = outerPoint;\r\n\t\t\tvar lastInner = innerPoint;\r\n\r\n\t\t\tif ( initialJoinIsOnLeftSide !== joinIsOnLeftSide ) {\r\n\r\n\t\t\t\tlastOuter = innerPoint;\r\n\t\t\t\tlastInner = outerPoint;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\tif ( isMiter || initialJoinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\tlastInner.toArray( vertices, 0 * 3 );\r\n\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\r\n\r\n\t\t\t\t\tif ( isMiter ) {\r\n\r\n\t\t\t\t\t\tlastOuter.toArray( vertices, 1 * 3 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( isMiter || ! initialJoinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\tlastInner.toArray( vertices, 1 * 3 );\r\n\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\r\n\r\n\t\t\t\t\tif ( isMiter ) {\r\n\r\n\t\t\t\t\t\tlastOuter.toArray( vertices, 0 * 3 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn numVertices;\r\n\r\n\t\t// -- End of algorithm\r\n\r\n\t\t// -- Functions\r\n\r\n\t\tfunction getNormal( p1, p2, result ) {\r\n\r\n\t\t\tresult.subVectors( p2, p1 );\r\n\t\t\treturn result.set( - result.y, result.x ).normalize();\r\n\r\n\t\t}\r\n\r\n\t\tfunction addVertex( position, u, v ) {\r\n\r\n\t\t\tif ( vertices ) {\r\n\r\n\t\t\t\tvertices[ currentCoordinate ] = position.x;\r\n\t\t\t\tvertices[ currentCoordinate + 1 ] = position.y;\r\n\t\t\t\tvertices[ currentCoordinate + 2 ] = 0;\r\n\r\n\t\t\t\tif ( normals ) {\r\n\r\n\t\t\t\t\tnormals[ currentCoordinate ] = 0;\r\n\t\t\t\t\tnormals[ currentCoordinate + 1 ] = 0;\r\n\t\t\t\t\tnormals[ currentCoordinate + 2 ] = 1;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcurrentCoordinate += 3;\r\n\r\n\t\t\t\tif ( uvs ) {\r\n\r\n\t\t\t\t\tuvs[ currentCoordinateUV ] = u;\r\n\t\t\t\t\tuvs[ currentCoordinateUV + 1 ] = v;\r\n\r\n\t\t\t\t\tcurrentCoordinateUV += 2;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tnumVertices += 3;\r\n\r\n\t\t}\r\n\r\n\t\tfunction makeCircularSector( center, p1, p2, u, v ) {\r\n\r\n\t\t\t// param p1, p2: Points in the circle arc.\r\n\t\t\t// p1 and p2 are in clockwise direction.\r\n\r\n\t\t\ttempV2_1.copy( p1 ).sub( center ).normalize();\r\n\t\t\ttempV2_2.copy( p2 ).sub( center ).normalize();\r\n\r\n\t\t\tvar angle = Math.PI;\r\n\t\t\tvar dot = tempV2_1.dot( tempV2_2 );\r\n\t\t\tif ( Math.abs( dot ) < 1 ) angle = Math.abs( Math.acos( dot ) );\r\n\r\n\t\t\tangle /= arcDivisions;\r\n\r\n\t\t\ttempV2_3.copy( p1 );\r\n\r\n\t\t\tfor ( var i = 0, il = arcDivisions - 1; i < il; i ++ ) {\r\n\r\n\t\t\t\ttempV2_4.copy( tempV2_3 ).rotateAround( center, angle );\r\n\r\n\t\t\t\taddVertex( tempV2_3, u, v );\r\n\t\t\t\taddVertex( tempV2_4, u, v );\r\n\t\t\t\taddVertex( center, u, 0.5 );\r\n\r\n\t\t\t\ttempV2_3.copy( tempV2_4 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\taddVertex( tempV2_4, u, v );\r\n\t\t\taddVertex( p2, u, v );\r\n\t\t\taddVertex( center, u, 0.5 );\r\n\r\n\t\t}\r\n\r\n\t\tfunction makeSegmentTriangles() {\r\n\r\n\t\t\taddVertex( lastPointR, u0, 1 );\r\n\t\t\taddVertex( lastPointL, u0, 0 );\r\n\t\t\taddVertex( currentPointL, u1, 0 );\r\n\r\n\t\t\taddVertex( lastPointR, u0, 1 );\r\n\t\t\taddVertex( currentPointL, u1, 1 );\r\n\t\t\taddVertex( currentPointR, u1, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tfunction makeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u ) {\r\n\r\n\t\t\tif ( innerSideModified ) {\r\n\r\n\t\t\t\t// Optimized segment + bevel triangles\r\n\r\n\t\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\t// Path segments triangles\r\n\r\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\r\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\r\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\r\n\r\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\r\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\r\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\r\n\r\n\t\t\t\t\t// Bevel join triangle\r\n\r\n\t\t\t\t\taddVertex( currentPointL, u, 0 );\r\n\t\t\t\t\taddVertex( nextPointL, u, 0 );\r\n\t\t\t\t\taddVertex( innerPoint, u, 0.5 );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// Path segments triangles\r\n\r\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\r\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\r\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\r\n\r\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\r\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\r\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\r\n\r\n\t\t\t\t\t// Bevel join triangle\r\n\r\n\t\t\t\t\taddVertex( currentPointR, u, 1 );\r\n\t\t\t\t\taddVertex( nextPointR, u, 0 );\r\n\t\t\t\t\taddVertex( innerPoint, u, 0.5 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// Bevel join triangle. The segment triangles are done in the main loop\r\n\r\n\t\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\taddVertex( currentPointL, u, 0 );\r\n\t\t\t\t\taddVertex( nextPointL, u, 0 );\r\n\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\taddVertex( currentPointR, u, 1 );\r\n\t\t\t\t\taddVertex( nextPointR, u, 0 );\r\n\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction createSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified ) {\r\n\r\n\t\t\tif ( innerSideModified ) {\r\n\r\n\t\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\r\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\r\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\r\n\r\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\r\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\r\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\r\n\r\n\t\t\t\t\taddVertex( currentPointL, u0, 0 );\r\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\r\n\r\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\t\t\t\t\taddVertex( nextPointL, u0, 0 );\r\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\r\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\r\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\r\n\r\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\r\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\r\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\r\n\r\n\t\t\t\t\taddVertex( currentPointR, u0, 1 );\r\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\r\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\r\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\r\n\t\t\t\t\taddVertex( nextPointR, u0, 1 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction addCapGeometry( center, p1, p2, joinIsOnLeftSide, start, u ) {\r\n\r\n\t\t\t// param center: End point of the path\r\n\t\t\t// param p1, p2: Left and right cap points\r\n\r\n\t\t\tswitch ( style.strokeLineCap ) {\r\n\r\n\t\t\t\tcase 'round':\r\n\r\n\t\t\t\t\tif ( start ) {\r\n\r\n\t\t\t\t\t\tmakeCircularSector( center, p2, p1, u, 0.5 );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tmakeCircularSector( center, p1, p2, u, 0.5 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'square':\r\n\r\n\t\t\t\t\tif ( start ) {\r\n\r\n\t\t\t\t\t\ttempV2_1.subVectors( p1, center );\r\n\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\r\n\r\n\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\r\n\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\r\n\r\n\t\t\t\t\t\t// Modify already existing vertices\r\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\r\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\r\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 3 * 3 );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\r\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 3 * 3 );\r\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\ttempV2_1.subVectors( p2, center );\r\n\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\r\n\r\n\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\r\n\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\r\n\r\n\t\t\t\t\t\tvar vl = vertices.length;\r\n\r\n\t\t\t\t\t\t// Modify already existing vertices\r\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 1 * 3 );\r\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 2 * 3 );\r\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 2 * 3 );\r\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 1 * 3 );\r\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'butt':\r\n\t\t\t\tdefault:\r\n\r\n\t\t\t\t\t// Nothing to do here\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction removeDuplicatedPoints( points ) {\r\n\r\n\t\t\t// Creates a new array if necessary with duplicated points removed.\r\n\t\t\t// This does not remove duplicated initial and ending points of a closed path.\r\n\r\n\t\t\tvar dupPoints = false;\r\n\t\t\tfor ( var i = 1, n = points.length - 1; i < n; i ++ ) {\r\n\r\n\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) < minDistance ) {\r\n\r\n\t\t\t\t\tdupPoints = true;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! dupPoints ) return points;\r\n\r\n\t\t\tvar newPoints = [];\r\n\t\t\tnewPoints.push( points[ 0 ] );\r\n\r\n\t\t\tfor ( var i = 1, n = points.length - 1; i < n; i ++ ) {\r\n\r\n\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) >= minDistance ) {\r\n\r\n\t\t\t\t\tnewPoints.push( points[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tnewPoints.push( points[ points.length - 1 ] );\r\n\r\n\t\t\treturn newPoints;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}();\r\n\r\nexport { SVGLoader };","C:\\Users\\lucas\\OneDrive\\Desktop\\GitHubProject\\typescript-porfolio-SP\\my-app\\src\\utils\\OrbitControls.js",["129","130","131","132","133","134","135","136","137"],"C:\\Users\\lucas\\OneDrive\\Desktop\\GitHubProject\\typescript-porfolio-SP\\my-app\\src\\index.tsx",[],"C:\\Users\\lucas\\OneDrive\\Desktop\\GitHubProject\\typescript-porfolio-SP\\my-app\\src\\theme.js",["138"],"C:\\Users\\lucas\\OneDrive\\Desktop\\GitHubProject\\typescript-porfolio-SP\\my-app\\src\\assets\\logo.jsx",["139"],"function Logo(props) {\r\n  const viewBox=`${props.w} -21.402 ${props.w} ${props.h}`\r\n  return (\r\n    <svg\r\n      width={props.w || 166.923}\r\n      height={props.h ||192.805}\r\n      xmlns=\"http://www.w3.org/2000/svg\"\r\n      viewBox=\"166.539 -21.402 166.923 192.805\"\r\n      style={{\r\n        background: \"0 0\",\r\n      }}\r\n      preserveAspectRatio=\"xMidYMid\"\r\n     \r\n    >\r\n      <defs>\r\n        <filter\r\n          id=\"prefix__editing-hover\"\r\n          x=\"-100%\"\r\n          y=\"-100%\"\r\n          width=\"300%\"\r\n          height=\"300%\"\r\n        >\r\n          <feFlood floodColor=\"#000\" result=\"flood\" />\r\n          <feComposite\r\n            operator=\"in\"\r\n            in2=\"SourceAlpha\"\r\n            in=\"flood\"\r\n            result=\"shadow\"\r\n          />\r\n          <feOffset dx={2.8} dy={-2.7} in=\"SourceGraphic\" result=\"offset-1\" />\r\n          <feOffset dx={-2.8} dy={2.7} in=\"shadow\" result=\"offset-2\" />\r\n          <feMerge>\r\n            <feMergeNode in=\"offset-2\" />\r\n            <feMergeNode in=\"offset-1\" />\r\n          </feMerge>\r\n        </filter>\r\n      </defs>\r\n      <g filter=\"url(#prefix__editing-hover)\">\r\n        <path\r\n          d=\"M212.1 46.7v51.23h29.3v5.37h-37.22V46.7h7.92zm75.8 48.41V80.28q0-1.73-.5-2.28-.5-.54-2.32-.54H258.6q-7.19 0-7.19-7.19V53.89q0-7.19 7.19-7.19h29.76q7.18 0 7.18 7.19v9.01h-8v-8.01q0-1.82-.5-2.32-.51-.5-2.33-.5h-22.47q-1.73 0-2.28.5-.54.5-.54 2.32v14.38q0 1.82.54 2.32.55.5 2.28.5h26.39q7.19 0 7.19 7.19v16.83q0 7.19-7.19 7.19h-29.85q-7.19 0-7.19-7.19V87.1h8.01v8.01q0 1.82.54 2.32.55.5 2.28.5h22.66q1.82 0 2.32-.5.5-.5.5-2.32z\"\r\n          fill=\"#70e000\"\r\n        />\r\n      </g>\r\n      <style />\r\n    </svg>\r\n  )\r\n}\r\n\r\nexport default Logo\r\n","C:\\Users\\lucas\\OneDrive\\Desktop\\GitHubProject\\typescript-porfolio-SP\\my-app\\src\\components\\icon.tsx",["140","141","142","143","144"],"C:\\Users\\lucas\\OneDrive\\Desktop\\GitHubProject\\typescript-porfolio-SP\\my-app\\src\\components\\layout\\particlesjs-config.js",[],"C:\\Users\\lucas\\OneDrive\\Desktop\\GitHubProject\\typescript-porfolio-SP\\my-app\\src\\components\\layout\\sidebar.tsx",["145","146","147","148","149","150","151","152","153"],"C:\\Users\\lucas\\OneDrive\\Desktop\\GitHubProject\\typescript-porfolio-SP\\my-app\\src\\components\\particles.jsx",[],"C:\\Users\\lucas\\OneDrive\\Desktop\\GitHubProject\\typescript-porfolio-SP\\my-app\\src\\pages\\skills.tsx",[],"C:\\Users\\lucas\\OneDrive\\Desktop\\GitHubProject\\typescript-porfolio-SP\\my-app\\src\\pages\\home.tsx",["154","155","156","157"],"C:\\Users\\lucas\\OneDrive\\Desktop\\GitHubProject\\typescript-porfolio-SP\\my-app\\src\\components\\layout\\pageLayout.tsx",[],{"ruleId":"158","severity":1,"message":"159","line":1,"column":17,"nodeType":"160","messageId":"161","endLine":1,"endColumn":26},{"ruleId":"158","severity":1,"message":"162","line":1,"column":28,"nodeType":"160","messageId":"161","endLine":1,"endColumn":34},{"ruleId":"158","severity":1,"message":"163","line":4,"column":8,"nodeType":"160","messageId":"161","endLine":4,"endColumn":15},{"ruleId":"164","severity":1,"message":"165","line":255,"column":11,"nodeType":"160","messageId":"166","endLine":255,"endColumn":18},{"ruleId":"164","severity":1,"message":"167","line":257,"column":17,"nodeType":"160","messageId":"166","endLine":257,"endColumn":18},{"ruleId":"164","severity":1,"message":"168","line":257,"column":24,"nodeType":"160","messageId":"166","endLine":257,"endColumn":26},{"ruleId":"164","severity":1,"message":"165","line":271,"column":11,"nodeType":"160","messageId":"166","endLine":271,"endColumn":18},{"ruleId":"164","severity":1,"message":"167","line":273,"column":17,"nodeType":"160","messageId":"166","endLine":273,"endColumn":18},{"ruleId":"164","severity":1,"message":"168","line":273,"column":24,"nodeType":"160","messageId":"166","endLine":273,"endColumn":26},{"ruleId":"164","severity":1,"message":"165","line":287,"column":11,"nodeType":"160","messageId":"166","endLine":287,"endColumn":18},{"ruleId":"164","severity":1,"message":"167","line":289,"column":17,"nodeType":"160","messageId":"166","endLine":289,"endColumn":18},{"ruleId":"164","severity":1,"message":"168","line":289,"column":24,"nodeType":"160","messageId":"166","endLine":289,"endColumn":26},{"ruleId":"164","severity":1,"message":"165","line":304,"column":11,"nodeType":"160","messageId":"166","endLine":304,"endColumn":18},{"ruleId":"164","severity":1,"message":"167","line":306,"column":17,"nodeType":"160","messageId":"166","endLine":306,"endColumn":18},{"ruleId":"164","severity":1,"message":"168","line":306,"column":24,"nodeType":"160","messageId":"166","endLine":306,"endColumn":26},{"ruleId":"164","severity":1,"message":"165","line":328,"column":11,"nodeType":"160","messageId":"166","endLine":328,"endColumn":18},{"ruleId":"164","severity":1,"message":"167","line":330,"column":17,"nodeType":"160","messageId":"166","endLine":330,"endColumn":18},{"ruleId":"164","severity":1,"message":"168","line":330,"column":24,"nodeType":"160","messageId":"166","endLine":330,"endColumn":26},{"ruleId":"164","severity":1,"message":"165","line":352,"column":11,"nodeType":"160","messageId":"166","endLine":352,"endColumn":18},{"ruleId":"164","severity":1,"message":"167","line":354,"column":17,"nodeType":"160","messageId":"166","endLine":354,"endColumn":18},{"ruleId":"164","severity":1,"message":"168","line":354,"column":24,"nodeType":"160","messageId":"166","endLine":354,"endColumn":26},{"ruleId":"164","severity":1,"message":"165","line":374,"column":11,"nodeType":"160","messageId":"166","endLine":374,"endColumn":18},{"ruleId":"164","severity":1,"message":"167","line":376,"column":17,"nodeType":"160","messageId":"166","endLine":376,"endColumn":18},{"ruleId":"164","severity":1,"message":"168","line":376,"column":24,"nodeType":"160","messageId":"166","endLine":376,"endColumn":26},{"ruleId":"164","severity":1,"message":"165","line":398,"column":11,"nodeType":"160","messageId":"166","endLine":398,"endColumn":18},{"ruleId":"164","severity":1,"message":"167","line":400,"column":17,"nodeType":"160","messageId":"166","endLine":400,"endColumn":18},{"ruleId":"164","severity":1,"message":"168","line":400,"column":24,"nodeType":"160","messageId":"166","endLine":400,"endColumn":26},{"ruleId":"169","severity":1,"message":"170","line":403,"column":30,"nodeType":"171","messageId":"172","endLine":403,"endColumn":32},{"ruleId":"169","severity":1,"message":"170","line":403,"column":61,"nodeType":"171","messageId":"172","endLine":403,"endColumn":63},{"ruleId":"164","severity":1,"message":"165","line":421,"column":11,"nodeType":"160","messageId":"166","endLine":421,"endColumn":18},{"ruleId":"164","severity":1,"message":"167","line":423,"column":17,"nodeType":"160","messageId":"166","endLine":423,"endColumn":18},{"ruleId":"164","severity":1,"message":"168","line":423,"column":24,"nodeType":"160","messageId":"166","endLine":423,"endColumn":26},{"ruleId":"164","severity":1,"message":"165","line":447,"column":11,"nodeType":"160","messageId":"166","endLine":447,"endColumn":18},{"ruleId":"164","severity":1,"message":"167","line":449,"column":17,"nodeType":"160","messageId":"166","endLine":449,"endColumn":18},{"ruleId":"164","severity":1,"message":"168","line":449,"column":24,"nodeType":"160","messageId":"166","endLine":449,"endColumn":26},{"ruleId":"164","severity":1,"message":"165","line":463,"column":11,"nodeType":"160","messageId":"166","endLine":463,"endColumn":18},{"ruleId":"164","severity":1,"message":"167","line":465,"column":17,"nodeType":"160","messageId":"166","endLine":465,"endColumn":18},{"ruleId":"164","severity":1,"message":"168","line":465,"column":24,"nodeType":"160","messageId":"166","endLine":465,"endColumn":26},{"ruleId":"164","severity":1,"message":"165","line":479,"column":11,"nodeType":"160","messageId":"166","endLine":479,"endColumn":18},{"ruleId":"164","severity":1,"message":"167","line":481,"column":17,"nodeType":"160","messageId":"166","endLine":481,"endColumn":18},{"ruleId":"164","severity":1,"message":"168","line":481,"column":24,"nodeType":"160","messageId":"166","endLine":481,"endColumn":26},{"ruleId":"164","severity":1,"message":"165","line":496,"column":11,"nodeType":"160","messageId":"166","endLine":496,"endColumn":18},{"ruleId":"164","severity":1,"message":"167","line":498,"column":17,"nodeType":"160","messageId":"166","endLine":498,"endColumn":18},{"ruleId":"164","severity":1,"message":"168","line":498,"column":24,"nodeType":"160","messageId":"166","endLine":498,"endColumn":26},{"ruleId":"164","severity":1,"message":"165","line":520,"column":11,"nodeType":"160","messageId":"166","endLine":520,"endColumn":18},{"ruleId":"164","severity":1,"message":"167","line":522,"column":17,"nodeType":"160","messageId":"166","endLine":522,"endColumn":18},{"ruleId":"164","severity":1,"message":"168","line":522,"column":24,"nodeType":"160","messageId":"166","endLine":522,"endColumn":26},{"ruleId":"164","severity":1,"message":"165","line":544,"column":11,"nodeType":"160","messageId":"166","endLine":544,"endColumn":18},{"ruleId":"164","severity":1,"message":"167","line":546,"column":17,"nodeType":"160","messageId":"166","endLine":546,"endColumn":18},{"ruleId":"164","severity":1,"message":"168","line":546,"column":24,"nodeType":"160","messageId":"166","endLine":546,"endColumn":26},{"ruleId":"164","severity":1,"message":"165","line":566,"column":11,"nodeType":"160","messageId":"166","endLine":566,"endColumn":18},{"ruleId":"164","severity":1,"message":"167","line":568,"column":17,"nodeType":"160","messageId":"166","endLine":568,"endColumn":18},{"ruleId":"164","severity":1,"message":"168","line":568,"column":24,"nodeType":"160","messageId":"166","endLine":568,"endColumn":26},{"ruleId":"164","severity":1,"message":"173","line":570,"column":12,"nodeType":"160","messageId":"166","endLine":570,"endColumn":14},{"ruleId":"164","severity":1,"message":"174","line":571,"column":12,"nodeType":"160","messageId":"166","endLine":571,"endColumn":14},{"ruleId":"164","severity":1,"message":"165","line":590,"column":11,"nodeType":"160","messageId":"166","endLine":590,"endColumn":18},{"ruleId":"164","severity":1,"message":"167","line":592,"column":17,"nodeType":"160","messageId":"166","endLine":592,"endColumn":18},{"ruleId":"164","severity":1,"message":"168","line":592,"column":24,"nodeType":"160","messageId":"166","endLine":592,"endColumn":26},{"ruleId":"169","severity":1,"message":"170","line":595,"column":30,"nodeType":"171","messageId":"172","endLine":595,"endColumn":32},{"ruleId":"169","severity":1,"message":"170","line":595,"column":55,"nodeType":"171","messageId":"172","endLine":595,"endColumn":57},{"ruleId":"164","severity":1,"message":"175","line":597,"column":12,"nodeType":"160","messageId":"166","endLine":597,"endColumn":17},{"ruleId":"169","severity":1,"message":"170","line":681,"column":12,"nodeType":"171","messageId":"172","endLine":681,"endColumn":14},{"ruleId":"169","severity":1,"message":"170","line":681,"column":23,"nodeType":"171","messageId":"172","endLine":681,"endColumn":25},{"ruleId":"176","severity":1,"message":"177","line":810,"column":23,"nodeType":"178","messageId":"179","endLine":810,"endColumn":24,"suggestions":"180"},{"ruleId":"176","severity":1,"message":"177","line":810,"column":41,"nodeType":"178","messageId":"179","endLine":810,"endColumn":42,"suggestions":"181"},{"ruleId":"176","severity":1,"message":"177","line":845,"column":23,"nodeType":"178","messageId":"179","endLine":845,"endColumn":24,"suggestions":"182"},{"ruleId":"176","severity":1,"message":"177","line":845,"column":41,"nodeType":"178","messageId":"179","endLine":845,"endColumn":42,"suggestions":"183"},{"ruleId":"176","severity":1,"message":"184","line":990,"column":46,"nodeType":"178","messageId":"179","endLine":990,"endColumn":47,"suggestions":"185"},{"ruleId":"186","severity":1,"message":"187","line":1181,"column":7,"nodeType":"188","messageId":"189","endLine":1293,"endColumn":8},{"ruleId":"164","severity":1,"message":"190","line":1187,"column":14,"nodeType":"160","messageId":"166","endLine":1187,"endColumn":16},{"ruleId":"164","severity":1,"message":"191","line":1188,"column":14,"nodeType":"160","messageId":"166","endLine":1188,"endColumn":16},{"ruleId":"164","severity":1,"message":"192","line":2219,"column":14,"nodeType":"160","messageId":"166","endLine":2219,"endColumn":15},{"ruleId":"164","severity":1,"message":"193","line":2219,"column":21,"nodeType":"160","messageId":"166","endLine":2219,"endColumn":22},{"ruleId":"186","severity":1,"message":"187","line":587,"column":3,"nodeType":"188","messageId":"189","endLine":609,"endColumn":4},{"ruleId":"169","severity":1,"message":"170","line":625,"column":29,"nodeType":"171","messageId":"172","endLine":625,"endColumn":31},{"ruleId":"169","severity":1,"message":"170","line":642,"column":29,"nodeType":"171","messageId":"172","endLine":642,"endColumn":31},{"ruleId":"169","severity":1,"message":"170","line":686,"column":29,"nodeType":"171","messageId":"172","endLine":686,"endColumn":31},{"ruleId":"169","severity":1,"message":"170","line":713,"column":29,"nodeType":"171","messageId":"172","endLine":713,"endColumn":31},{"ruleId":"186","severity":1,"message":"187","line":781,"column":3,"nodeType":"188","messageId":"189","endLine":790,"endColumn":4},{"ruleId":"186","severity":1,"message":"187","line":798,"column":3,"nodeType":"188","messageId":"189","endLine":807,"endColumn":4},{"ruleId":"186","severity":1,"message":"187","line":813,"column":3,"nodeType":"188","messageId":"189","endLine":822,"endColumn":4},{"ruleId":"186","severity":1,"message":"187","line":940,"column":3,"nodeType":"188","messageId":"189","endLine":966,"endColumn":4},{"ruleId":"194","severity":1,"message":"195","line":9,"column":1,"nodeType":"196","endLine":22,"endColumn":4},{"ruleId":"197","severity":1,"message":"198","line":2,"column":9,"nodeType":"160","messageId":"161","endLine":2,"endColumn":16},{"ruleId":"158","severity":1,"message":"199","line":1,"column":10,"nodeType":"160","messageId":"161","endLine":1,"endColumn":19},{"ruleId":"158","severity":1,"message":"200","line":1,"column":21,"nodeType":"160","messageId":"161","endLine":1,"endColumn":24},{"ruleId":"158","severity":1,"message":"201","line":1,"column":32,"nodeType":"160","messageId":"161","endLine":1,"endColumn":37},{"ruleId":"158","severity":1,"message":"202","line":1,"column":39,"nodeType":"160","messageId":"161","endLine":1,"endColumn":49},{"ruleId":"158","severity":1,"message":"203","line":1,"column":51,"nodeType":"160","messageId":"161","endLine":1,"endColumn":56},{"ruleId":"158","severity":1,"message":"159","line":1,"column":17,"nodeType":"160","messageId":"161","endLine":1,"endColumn":26},{"ruleId":"158","severity":1,"message":"162","line":1,"column":28,"nodeType":"160","messageId":"161","endLine":1,"endColumn":34},{"ruleId":"158","severity":1,"message":"204","line":1,"column":36,"nodeType":"160","messageId":"161","endLine":1,"endColumn":45},{"ruleId":"158","severity":1,"message":"203","line":2,"column":45,"nodeType":"160","messageId":"161","endLine":2,"endColumn":50},{"ruleId":"158","severity":1,"message":"205","line":2,"column":52,"nodeType":"160","messageId":"161","endLine":2,"endColumn":56},{"ruleId":"158","severity":1,"message":"206","line":4,"column":5,"nodeType":"160","messageId":"161","endLine":4,"endColumn":22},{"ruleId":"158","severity":1,"message":"207","line":5,"column":5,"nodeType":"160","messageId":"161","endLine":5,"endColumn":19},{"ruleId":"158","severity":1,"message":"208","line":11,"column":5,"nodeType":"160","messageId":"161","endLine":11,"endColumn":18},{"ruleId":"158","severity":1,"message":"209","line":15,"column":18,"nodeType":"160","messageId":"161","endLine":15,"endColumn":28},{"ruleId":"158","severity":1,"message":"159","line":1,"column":15,"nodeType":"160","messageId":"161","endLine":1,"endColumn":24},{"ruleId":"158","severity":1,"message":"162","line":1,"column":25,"nodeType":"160","messageId":"161","endLine":1,"endColumn":31},{"ruleId":"158","severity":1,"message":"204","line":1,"column":32,"nodeType":"160","messageId":"161","endLine":1,"endColumn":41},{"ruleId":"158","severity":1,"message":"200","line":2,"column":10,"nodeType":"160","messageId":"161","endLine":2,"endColumn":13},"@typescript-eslint/no-unused-vars","'useEffect' is defined but never used.","Identifier","unusedVar","'useRef' is defined but never used.","'SideBar' is defined but never used.","no-redeclare","'numbers' is already defined.","redeclared","'j' is already defined.","'jl' is already defined.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","'rx' is already defined.","'ry' is already defined.","'start' is already defined.","no-useless-escape","Unnecessary escape character: \\..","Literal","unnecessaryEscape",["210","211"],["212","213"],["214","215"],["216","217"],"Unnecessary escape character: \\-.",["218","219"],"default-case","Expected a default case.","SwitchStatement","missingDefaultCase","'tx' is already defined.","'ty' is already defined.","'i' is already defined.","'n' is already defined.","import/no-anonymous-default-export","Assign object to a variable before exporting as module default","ExportDefaultDeclaration","no-unused-vars","'viewBox' is assigned a value but never used.","'Container' is defined but never used.","'Box' is defined but never used.","'Stack' is defined but never used.","'SimpleGrid' is defined but never used.","'Image' is defined but never used.","'Component' is defined but never used.","'Link' is defined but never used.","'AiOutlineAppstore' is defined but never used.","'AiOutlineAudit' is defined but never used.","'AiOutlineMenu' is defined but never used.","'WouterLink' is defined but never used.",{"messageId":"220","fix":"221","desc":"222"},{"messageId":"223","fix":"224","desc":"225"},{"messageId":"220","fix":"226","desc":"222"},{"messageId":"223","fix":"227","desc":"225"},{"messageId":"220","fix":"228","desc":"222"},{"messageId":"223","fix":"229","desc":"225"},{"messageId":"220","fix":"230","desc":"222"},{"messageId":"223","fix":"231","desc":"225"},{"messageId":"220","fix":"232","desc":"222"},{"messageId":"223","fix":"233","desc":"225"},"removeEscape",{"range":"234","text":"235"},"Remove the `\\`. This maintains the current functionality.","escapeBackslash",{"range":"236","text":"237"},"Replace the `\\` with `\\\\` to include the actual backslash character.",{"range":"238","text":"235"},{"range":"239","text":"237"},{"range":"240","text":"235"},{"range":"241","text":"237"},{"range":"242","text":"235"},{"range":"243","text":"237"},{"range":"244","text":"235"},{"range":"245","text":"237"},[19146,19147],"",[19146,19146],"\\",[19164,19165],[19164,19164],[19684,19685],[19684,19684],[19702,19703],[19702,19702],[23460,23461],[23460,23460]]